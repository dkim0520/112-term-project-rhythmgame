####
# TP RhythmPlatform
####
import sys
import pygame
from character import Character
from Platform import Platform
from PointCircle import PointCircle
from osuDataParser import *
###
# initialization
###
import pygame

###Framework obtained from Lukas Peraza http://blog.lukasperaza.com/getting-started-with-pygame/
class PygameGame(object):

    def init(self):
        self.state = "Start Menu" #different games states for different modes
        self.pause = False
        self.prevState = ""

        self.recentfilePath = ""

        self.startPlatLength = 3000

        self.finalPlatform = 0

        #highlights
        self.highlight = 5
        self.playHighlight = False
        self.editHighlight = False
        self.loadFileHighlight = False
        self.tutorialHighlight = False
        self.backLoadHighlight = False
        self.retryHighlight = False
        self.backFailHighlight = False
        self.backWinHighlight = False

        Character.init()
        character = Character(self.width/2, self.height/2)
        self.characterGroup = pygame.sprite.GroupSingle(character)

        Platform.init()
        platform = Platform(self.width, self.height, 25)
        self.platformGroup = pygame.sprite.Group(platform)

        #fonts
        self.startFont = pygame.font.SysFont('Helvetica', self.width//8)
        self.playFont = pygame.font.SysFont("Helvetica", self.width//16)
        self.retryFont = pygame.font.SysFont("Helvetica", self.width//18)
        self.backFont = pygame.font.SysFont("Helvetica", 50)

    def mousePressed(self, x, y):
        #load file menu
        if self.state == "Start Menu" and self.width/2 - 100 <= x <= self.width/2 + 100 and self.height/2 - 50 <= y <= self.height/2 + 30:
            self.state = "Load File State"
            
        #back button mouse press
        elif self.state == "Load File State" and 0 <= x <= 50 and 0 <= y <= 50:
            self.state = "Start Menu"

        #start default level
        elif self.state == "Load File State" and self.width/2 - 100 <= x <= self.width/2 + 100 and self.height/2 - 140 <= y <= self.height/2 - 60:
            self.state = "Game State"
            self.recentfilePath = "Game"
            Character.init()
            character = Character(self.width/2, self.height/2 - 25)
            self.characterGroup = pygame.sprite.GroupSingle(character)

            Platform.init()
            platform = Platform(0, self.height/2 + 25, self.startPlatLength)
            self.platformGroup = pygame.sprite.Group(platform)

            PointCircle.init()
            pointCircle = PointCircle(0, self.height/2 + 40)
            self.pointCircleGroup = pygame.sprite.Group(pointCircle)

        #failed screen retry button
        elif self.state == "Lost" and self.width/2 - 50 <= x <= self.width/2 + 50 and self.height/2 + 20 <= y <= self.height/2 + 60:
            if self.recentfilePath == "":
                Character.init()
                character = Character(self.width/2, self.height/2 - 25)
                self.characterGroup = pygame.sprite.GroupSingle(character)

                Platform.init()
                platform = Platform(0, self.height/2 + 25, self.startPlatLength)
                self.platformGroup = pygame.sprite.Group(platform)

                PointCircle.init()
                pointCircle = PointCircle(0, self.height/2 + 40)
                self.pointCircleGroup = pygame.sprite.Group(pointCircle)

            else:
                Character.init()
                character = Character(self.width/2, self.height/2 - 25)
                self.characterGroup = pygame.sprite.GroupSingle(character)

                Platform.init()
                platform = Platform(self.width/2, self.height/2 + 25, 0)
                self.platformGroup = pygame.sprite.Group(platform)

                PointCircle.init()
                pointCircle = PointCircle(0, self.height/2 + 40)
                self.pointCircleGroup = pygame.sprite.Group(pointCircle)
                
                self.finalPlatform = 0
                for hitButton in parseHitObjectData(getHitObject("Songs" + os.sep + self.recentfilePath))[0]:
                    if hitButton[1] > self.finalPlatform:
                        self.finalPlatform = hitButton[1]
                    if hitButton[0] > self.height:
                        self.platformGroup.add(Platform(hitButton[1]//10 - 500, self.height, 50))
                    else:
                        self.platformGroup.add(Platform(hitButton[1]//10 - 500, hitButton[0], 50))

                pygame.mixer.music.load("Songs" + os.sep + parseHitObjectData(getHitObject("Songs" + os.sep + self.recentfilePath))[1])

                #removes the file where the data was parsed for logistical reasons
                os.remove("Songs" + os.sep + self.recentfilePath + " hitObjects")

                #creates a first platform to start from
                workingFirstX, workingFirstY = self.finalPlatform, 0
                for platform in self.platformGroup:
                    if platform.x < workingFirstX:
                        workingFirstX, workingFirstY = platform.x, platform.y
                firstPlatform = (workingFirstX, workingFirstY)

                for platform in self.platformGroup:
                    self.pointCircleGroup.add(PointCircle(platform.x + 15, platform.y - 30))

                self.platformGroup.add(Platform(firstPlatform[0], firstPlatform[1], 1500))
                for character in self.characterGroup:
                    character.x, character.y = firstPlatform


                #plays music associated with file
                pygame.mixer.music.play()
                self.state = "%s State" %(self.recentfilePath)

        #failed screen back button
        elif self.state == "Lost" and self.width/2 - 50 <= x <= self.width/2 + 50 and self.height/2 + 70 <= y <= self.height/2 + 110:
            self.state = "Load File State"

        #load file
        elif self.state == "Load File State" and self.width/2 - 100 <= x <= self.width/2 + 100 and self.height/2 - 40 <= y <= self.height/2 + 40:
            #checks if valid file type and file exists
            tempCheck = input("Paste the name of the file here: ")
            #if found, loads location of each platform
            while tempCheck not in os.listdir("Songs") or tempCheck[-4:] != ".osu":
                tempCheck = input("Paste the name of a valid file here: ")
            self.recentfilePath = tempCheck
            
            #initialize character and starting platform again
            Character.init()
            character = Character(self.width/2, self.height/2 - 25)
            self.characterGroup = pygame.sprite.GroupSingle(character)

            Platform.init()
            platform1 = Platform(self.width/2, self.height/2 + 25, 0)
            self.platformGroup = pygame.sprite.Group(platform1)

            PointCircle.init()
            pointCircle = PointCircle(0, self.height/2 + 40)
            self.pointCircleGroup = pygame.sprite.Group(pointCircle)

            self.finalPlatform = 0
            for hitButton in parseHitObjectData(getHitObject("Songs" + os.sep + self.recentfilePath))[0]:
                if hitButton[1] > self.finalPlatform:
                    self.finalPlatform = hitButton[1]
                if hitButton[0] > self.height:
                    self.platformGroup.add(Platform(hitButton[1]//10 - 500, self.height, 50))
                else:
                    self.platformGroup.add(Platform(hitButton[1]//10 - 500, hitButton[0], 50))

            pygame.mixer.music.load("Songs" + os.sep + parseHitObjectData(getHitObject("Songs" + os.sep + self.recentfilePath))[1])

            #removes the file where the data was parsed for logistical reasons
            os.remove("Songs" + os.sep + self.recentfilePath + " hitObjects")

            #add platforms after initializing them
            for platform in self.platformGroup:
                if platform.x > self.width/2:
                    self.pointCircleGroup.add(PointCircle(platform.x + 15, platform.y - 30))

            #creates final platform
            self.platformGroup.add(Platform(self.finalPlatform, self.height - 30, 1500))

            #creates a first platform to start from
            workingFirstX, workingFirstY = self.finalPlatform, 0
            for platform in self.platformGroup:
                if platform.x < workingFirstX:
                    workingFirstX, workingFirstY = platform.x, platform.y
            firstPlatform = (workingFirstX, workingFirstY)

            self.platformGroup.add(Platform(firstPlatform[0], firstPlatform[1], 1500))
            #sets character on starting platform
            for character in self.characterGroup:
                character.x, character.y = firstPlatform

            #plays music associated with file
            pygame.mixer.music.play()
            self.state = "%s State" %(self.recentfilePath)

        #win screen back button
        elif self.state == "Win" and self.width/2 - 50 <= x <= self.width/2 + 50 and self.height/2 + 70 <= y <= self.height/2 + 110:
            self.state = "Load File State"

    def mouseReleased(self, x, y):
        pass

    def mouseMotion(self, x, y):
        #highlight for play game
        if self.state == "Start Menu" and self.width/2 - 100 <= x <= self.width/2 + 100 and self.height/2 - 50 <= y <= self.height/2 + 30:
            self.playHighlight = True
        else:
            self.playHighlight = False

        #highlight for edit button
        if self.state == "Start Menu" and self.width/2 - 100 <= x <= self.width/2 + 100 and self.height/2 + 75 <= y <= self.height/2 + 155:
            self.editHighlight = True
        else:
            self.editHighlight = False

        #highlight for play default button
        if self.state == "Load File State" and self.width/2 -100 <= x <= self.width/2 + 100 and self.height/2 - 140<= y <= self.height/2 - 60:
            self.tutorialHighlight = True
        else:
            self.tutorialHighlight = False

        #highlight for load file back button
        if self.state == "Load File State" and 0 <= x <= 50 and 0 <= y <= 50:
            self.backLoadHighlight = True
        else:
            self.backLoadHighlight = False

        #highlight for load file button
        if self.state == "Load File State" and self.width/2 - 100 <= x <= self.width/2 + 100 and self.height/2 - 40 <= y <= self.height/2 + 40:
            self.loadFileHighlight = True
        else:
            self.loadFileHighlight = False

        if self.state == "Lost" and self.width/2 - 50 <= x <= self.width/2 + 50 and self.height/2 + 20 <= y <= self.height/2 + 60:
            self.retryHighlight = True
        else:
            self.retryHighlight = False

        #highlight for fail back button
        if self.state == "Lost" and self.width/2 - 50 <= x <= self.width/2 + 50 and self.height/2 + 70 <= y <= self.height/2 + 110:
            self.backFailHighlight = True
        else:
            self.backFailHighlight = False

        #highlight for win back button
        if self.state == "Win" and self.width/2 - 50 <= x <= self.width/2 + 50 and self.height/2 + 70 <= y <= self.height/2 + 110:
            self.backWinHighlight = True
        else:
            self.backWinHighlight = False

    def mouseDrag(self, x, y):
        pass

    def keyPressed(self, keyCode, modifier):
        if keyCode == pygame.K_ESCAPE:
            if self.pause == True:
                self.state = self.prevState
                self.pause = False
            elif self.pause == False:
                self.pause = True
                self.prevState = self.state
                self.state = "Pause"

            

    def keyReleased(self, keyCode, modifier):
        pass

    def timerFired(self, dt):
        if self.state != "%s State" %(self.recentfilePath): return
        self.timesFired += 1
        self.platformGroup.update(self.isKeyPressed, self.width, self.height)
        self.characterGroup.update(self.isKeyPressed, self.width, self.height)
        self.pointCircleGroup.update(self.isKeyPressed, self.width, self.height)

        for character in pygame.sprite.groupcollide(
            self.characterGroup, self.platformGroup, False, False):
            # checks collisions with platforms and modifies character accordingly
            character.isJump = False
            character.onPlatform = True
            character.canJump = True
            for platform in pygame.sprite.groupcollide(self.platformGroup, self.characterGroup, False, False):
                character.scroll = platform.scroll
                if character.y < platform.y:
                    character.y = platform.y + 25
                if character.onPlatform:    
                    character.y = platform.y - 30
                    character.velocity = 0 
                    character.angle = 90
                elif character.x + 25 < platform.x:
                    character.x = platform.x - 45

        for character in pygame.sprite.groupcollide(
            self.characterGroup, self.pointCircleGroup, False, True):
            character.points += 100

        for platforms in self.platformGroup:
            platforms.scroll = (-2, 0)
            if platforms.x + platforms.length < 0:
                self.platformGroup.remove(platforms)

        for character in self.characterGroup:
            if not character.isJump and self.state == "%s State" %(self.recentfilePath):
                character.onPlatform = False

            if character.y >= self.height:
                self.state = "Lost"
                pygame.mixer.music.stop()

            if character.x == self.finalPlatform + 1300:
                self.state = "Win"
                pygame.mixer.music.stop()

            elif character.isJump:
                character.canJump = False


        if self.state == "Game State":
            if self.timesFired % 50 == 0: #adds platforms every so often
                self.platformGroup.add(Platform(self.width + self.startPlatLength/3, self.height/2 + 25, 70))
                self.pointCircleGroup.add(PointCircle(self.width + self.startPlatLength/3 + 35, self.height/2 - 55))
            if self.timesFired % 50 == 25:
                self.platformGroup.add(Platform(self.width + self.startPlatLength/3, self.height/2 - 25, 75))
                self.pointCircleGroup.add(PointCircle(self.width + self.startPlatLength/3 + 35, self.height/2))

            for char in self.characterGroup:
                for platform in self.platformGroup:
                    platform.scroll = (-2, 0)

    def redrawAll(self, screen):
        if self.state == "Start Menu":
            screen.fill((0, 255, 0))
            screen.blit(self.startFont.render('PyRhythm Platformer', True, 
                                              (255,0,0)), (0, 0))
            
            #play button
            pygame.draw.rect(screen, (100, 155, 155), (self.width/2 - 100, 
                             self.height/2 - 50, 200, 80))
            screen.blit(self.playFont.render("Play Game", True,
                                            (0, 0, 0)), (self.width/2 - 75, self.height/2 - 35))

            #play button highlight
            if self.playHighlight:
                pygame.draw.rect(screen, (255, 255, 0), (self.width/2 - 100,
                             self.height/2 - 50, 200, 80), self.highlight)

            #edit button
            pygame.draw.rect(screen, (100, 155, 155), (self.width/2 - 100,
                             self.height/2 + 75, 200, 80))

            #edit button highlight
            if self.editHighlight:
                pygame.draw.rect(screen, (255, 255, 0), (self.width/2 - 100,
                                 self.height/2 + 75, 200, 80), self.highlight)

        elif self.state == "Load File State":
            screen.fill((0, 255, 0))
            #back button
            pygame.draw.rect(screen, (155, 0, 0), (0, 0, 50, 50))
            screen.blit(self.backFont.render("<", True, (0, 0, 0)),
                        (10, 0))

            #back button highlight
            if self.backLoadHighlight:
                pygame.draw.rect(screen, (255, 255, 0), (0, 0, 50, 50), self.highlight)

            #play default/tutorial level
            pygame.draw.rect(screen,(100, 155, 155), (self.width/2 - 100,
                             self.height/2 - 140, 200, 80))
            screen.blit(self.playFont.render("Tutorial Level", True, (0, 0, 0)),
                        (self.width/2 - 90, self.height/2 - 120))

            #default/tutorial level highlight
            if self.tutorialHighlight:
                pygame.draw.rect(screen, (255, 255, 0), (self.width/2 - 100, 
                                 self.height/2 - 140, 200, 80), self.highlight)

            #load file button
            pygame.draw.rect(screen, (100, 155, 155), (self.width/2 - 100,
                             self.height/2 - 40, 200, 80))
            screen.blit(self.playFont.render("Load File", True, (0, 0, 0)),
                        (self.width/2 - 62, self.height/2 - 20))

            #load file highlight
            if self.loadFileHighlight:
                pygame.draw.rect(screen, (255, 255, 0), (self.width/2 - 100,
                                 self.height/2 - 40, 200, 80), self.highlight)

        elif self.state == "Game State" or self.state == "%s State" %(self.recentfilePath):
            self.characterGroup.draw(screen)
            self.platformGroup.draw(screen)
            self.pointCircleGroup.draw(screen)
            for character in self.characterGroup:
                points = character.points
            if points < 1000:
                screen.blit(self.retryFont.render("Points: %d" %(points), True, (0, 0, 0)),
                            (self.width - 150, 10))
            elif 1000 <= points < 10000:
                screen.blit(self.retryFont.render("Points: %d" %(points), True, (0, 0, 0)),
                             (self.width - 170, 10))
            else:
                screen.blit(self.retryFont.render("Points: %d" %(points), True, (0, 0 ,0)),
                            (self.width - 190, 10))

        elif self.state == "Lost":
            screen.fill((255, 0, 0))
            screen.blit(self.startFont.render("Failed!", True, (0, 0, 0)), 
                        (self.width/2 - 90, self.height/2 - 100))

            #retry button
            pygame.draw.rect(screen, (100, 155, 155), 
                            (self.width/2 - 50, self.height/2 + 20, 100, 40))
            screen.blit(self.retryFont.render("Retry", True, (0, 0, 0)),
                        (self.width/2 - 32, self.height/2 + 18))

            #retry highlight
            if self.retryHighlight:
                pygame.draw.rect(screen, (255, 255, 0),
                            (self.width/2 - 50, self.height/2 + 20, 100, 40), self.highlight)

            #main menu button
            pygame.draw.rect(screen, (100, 155, 155),
                            (self.width/2 - 50, self.height/2 + 70, 100, 40))
            screen.blit(self.retryFont.render("Back", True, (0, 0, 0)),
                        (self.width/2 - 32, self.height/2 + 68))

            #main menu highlight
            if self.backFailHighlight:
                pygame.draw.rect(screen, (255, 255, 0),
                            (self.width/2 - 50, self.height/2 + 70, 100, 40), self.highlight)

        elif self.state == "Win":
            screen.fill((0, 255, 0))
            screen.blit(self.startFont.render("Success!", True, (0, 0, 0)),
                        (self.width/2 - 90, self.height/2 - 100))

            #main menu button
            pygame.draw.rect(screen, (100, 155, 155),
                            (self.width/2 - 50, self.height/2 + 70, 100, 40))
            screen.blit(self.retryFont.render("Back", True, (0, 0, 0)),
                        (self.width/2 - 32, self.height/2 + 68))

            #main menu highlight
            if self.backWinHighlight:
                pygame.draw.rect(screen, (255, 255, 0),
                            (self.width/2 - 50, self.height/2 + 70, 100, 40), self.highlight)

        elif self.state == "Pause":
            self.characterGroup.draw(screen)
            self.platformGroup.draw(screen)
            self.pointCircleGroup.draw(screen)
            pauseScreen = pygame.Surface((self.width, self.height))
            pauseScreen.set_alpha(100)
            pauseScreen.fill((155, 155, 155))
            screen.blit(pauseScreen, (0, 0))

    def isKeyPressed(self, key):
        ''' return whether a specific key is being held '''
        return self._keys.get(key, False)

    def __init__(self, width=600, height=400, fps=50, title="PyRhythm Platformer"):
        self.width = width
        self.height = height
        self.fps = fps
        self.title = title
        self.timesFired = 0
        pygame.init()

    def run(self):

        clock = pygame.time.Clock()
        screen = pygame.display.set_mode((self.width, self.height))
        # set the title of the window
        pygame.display.set_caption(self.title)

        # stores all the keys currently being held down
        self._keys = dict()

        # call game-specific initialization
        self.init()
        playing = True
        while playing:
            time = clock.tick(self.fps)
            self.timerFired(time)
            for event in pygame.event.get():
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    self.mousePressed(*(event.pos))
                elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
                    self.mouseReleased(*(event.pos))
                elif (event.type == pygame.MOUSEMOTION and
                      event.buttons == (0, 0, 0)):
                    self.mouseMotion(*(event.pos))
                elif (event.type == pygame.MOUSEMOTION and
                      event.buttons[0] == 1):
                    self.mouseDrag(*(event.pos))
                elif event.type == pygame.KEYDOWN:
                    self._keys[event.key] = True
                    self.keyPressed(event.key, event.mod)
                elif event.type == pygame.KEYUP:
                    self._keys[event.key] = False
                    self.keyReleased(event.key, event.mod)
                elif event.type == pygame.QUIT:
                    playing = False
            screen.fill((255, 255, 255))
            self.redrawAll(screen)
            pygame.display.flip()

        pygame.quit()

PygameGame().run()